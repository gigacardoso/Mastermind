;Francisco Afonso Raposo 66986 | Ricardo Daniel da Silva Bento 67065 | Diogo Costa Relvas Garcia 66971 ||| Grupo 90
;Nota: Só os construtores, os testes e os reconhecedores testam os argumentos de forma a não sobrecarregar com código.
(require (lib "misc.ss" "swindle"))
;Tipo Pino Chave
;Reconhecedor
(define (pino-chave? arg)
  (if (symbol? arg)
      (or (eq? arg 'red)
          (eq? arg 'aqua)
          (eq? arg 'brown)
          (eq? arg 'orange)
          (eq? arg 'yellow)
          (eq? arg 'lime)
          (eq? arg 'white))
      #f))
;Transformador
(define (pino-chave->string pc)
  (string-append "|pino-chave%" 
                 (symbol->string pc) 
                 "|"))
;Tipo Sequência de Pinos Chave
;Construtor
(define (cria-seq-pinos-chave p1 p2 p3 p4)
  (if (and (pino-chave? p1) 
           (pino-chave? p2) 
           (pino-chave? p3) 
           (pino-chave? p4))
      (list p1 p2 p3 p4)
      (error "cria-seq-pinos-chave :argumento(s) inválido(s) (não é pino-chave)")))
;Selector
(define (elemento-i-seq-pinos-chave s i)
  (cond ((= 1 i) (car s))
        ((= 2 i) (car (cdr s)))
        ((= 3 i) (car (cdr (cdr s))))
        ((= 4 i) (car (cdr (cdr (cdr s)))))))
;Reconhecedor
(define (seq-pinos-chave? arg)
  (if (list? arg)
      (and (pino-chave? (elemento-i-seq-pinos-chave arg 1))
           (pino-chave? (elemento-i-seq-pinos-chave arg 2))
           (pino-chave? (elemento-i-seq-pinos-chave arg 3))
           (pino-chave? (elemento-i-seq-pinos-chave arg 4)))
      #f))
;Teste
(define (seq-pinos-chave=? s1 s2)
  (if (and (seq-pinos-chave? s1)
           (seq-pinos-chave? s2))
      (and (eq? (elemento-i-seq-pinos-chave s1 1) (elemento-i-seq-pinos-chave s2 1))
           (eq? (elemento-i-seq-pinos-chave s1 2) (elemento-i-seq-pinos-chave s2 2))
           (eq? (elemento-i-seq-pinos-chave s1 3) (elemento-i-seq-pinos-chave s2 3))
           (eq? (elemento-i-seq-pinos-chave s1 4) (elemento-i-seq-pinos-chave s2 4)))
      (error "seq-pinos-chave=?:argumento(s) inválido(s) (não é seq-pinos-chave)")))
;Transformador
(define (seq-pinos-chave->string s)
  (string-append "|seq-pinos-chave%" 
                 (pino-chave->string (elemento-i-seq-pinos-chave s 1))
                 "%" 
                 (pino-chave->string (elemento-i-seq-pinos-chave s 2)) 
                 "%" 
                 (pino-chave->string (elemento-i-seq-pinos-chave s 3)) 
                 "%" 
                 (pino-chave->string (elemento-i-seq-pinos-chave s 4)) 
                 "|"))
;Tipo Resposta
;Construtor
(define (faz-resposta p v)
  (if (and (integer? p)
           (integer? v)
           (>= p 0)
           (<= p 4)
           (>= v 0)
           (<= v 4)
           (<= (+ p v) 4)
           (not (and (= p 3)
                     (= v 1))))
      (cons p v)
      (error "faz-resposta:argumento(s) inválido(s)"
             p
             v)))
;Selectores
(define (resposta-pretos r)
  (car r))
(define (resposta-vermelhos r)
  (cdr r))
;Reconhecedor
(define (resposta? arg)
  (if (pair? arg)
      (and (integer? (car arg))
           (integer? (cdr arg))
           (>= (car arg) 0)
           (<= (car arg) 4)
           (>= (cdr arg) 0)
           (<= (cdr arg) 4)
           (<= (+ (car arg) (cdr arg)) 4)
           (not (and (= (car arg) 3)
                     (= (cdr arg) 1))))
      #f))
;Teste
(define (resposta=? r1 r2)
  (if (and (resposta? r1)
           (resposta? r2))
      (and (= (resposta-pretos r1)
              (resposta-pretos r2))
           (= (resposta-vermelhos r1)
              (resposta-vermelhos r2)))
      (error "resposta=?:argumento(s) inválido(s) (não é resposta)")))
;Transformador
(define (resposta->string r)
  (string-append "|resposta%"
                 (number->string (resposta-pretos r))
                 "%"
                 (number->string (resposta-vermelhos r))
                 "|"))
;Tipo Jogada
;Construtor
(define (faz-jogada s r)
  (if (and (seq-pinos-chave? s)
           (resposta? r))
      (cons s r)
      (error "faz-jogada:argumento(s) inválido(s) (primeiro argumento não é seq-pinos-chave ou segundo argumento não é resposta)")))
;Selectores
(define (jogada-seq-pinos-chave j)
  (car j))
(define (jogada-resposta j)
  (cdr j))
;Reconhecedor
(define (jogada? arg)
  (if (pair? arg)
      (and (seq-pinos-chave? (car arg))
           (resposta? (cdr arg)))
      #f))
;Transformador
(define (jogada->string j)
  (string-append "|jogada%"
                 (seq-pinos-chave->string (jogada-seq-pinos-chave j))
                 "%"
                 (resposta->string (jogada-resposta j))
                 "|"))
;Tipo Jogadas
;Construtores
(define (jogadas j)
  (if (jogada? j)
      (vector j j j j j j j j j j j j)
      (error "jogadas:argumento inválido (não é jogada)")))
;Modificador
(define (altera-jogadas! js i j)
  (define (altera-jogadas-aux! js i j)
    (vector-set! js (- i 1) j))
  (if (not (and (integer? i)
                (>= i 1)
                (<= i 12)))
      (error "altera-jogadas!:elemento inválido (tem de ser inteiro e entre 1 e 12)")
      (altera-jogadas-aux! js i j)))
;Selector
(define (jogadas-i js i)
  (vector-ref js (- i 1)))
;Reconhecedor
(define (jogadas? arg)
  (if (vector? arg)
      (and (jogada? (jogadas-i arg 1))
           (jogada? (jogadas-i arg 2))
           (jogada? (jogadas-i arg 3))
           (jogada? (jogadas-i arg 4))
           (jogada? (jogadas-i arg 5))
           (jogada? (jogadas-i arg 6))
           (jogada? (jogadas-i arg 7))
           (jogada? (jogadas-i arg 8))
           (jogada? (jogadas-i arg 9))
           (jogada? (jogadas-i arg 10))
           (jogada? (jogadas-i arg 11))
           (jogada? (jogadas-i arg 12)))
      #f))
;Transformador
(define (jogadas->string js)
  (string-append "|jogadas%"
                 (jogada->string (jogadas-i js 1))
                 "%"
                 (jogada->string (jogadas-i js 2))
                 "%"
                 (jogada->string (jogadas-i js 3))
                 "%"
                 (jogada->string (jogadas-i js 4))
                 "%"
                 (jogada->string (jogadas-i js 5))
                 "%"
                 (jogada->string (jogadas-i js 6))
                 "%"
                 (jogada->string (jogadas-i js 7))
                 "%"
                 (jogada->string (jogadas-i js 8))
                 "%"
                 (jogada->string (jogadas-i js 9))
                 "%"
                 (jogada->string (jogadas-i js 10))
                 "%"
                 (jogada->string (jogadas-i js 11))
                 "%"
                 (jogada->string (jogadas-i js 12))
                 "|"))
;Código apresentado no enunciado
(define mm-interface null)
(define mm-controle null)
(require "interface.zo")
(define (mastermind nome-utilizador tipo)
  (set! mm-interface (fpmm-cria-interface))
  (set! mm-controle (cria-controle nome-utilizador tipo)))
(define (em obj mens . args)
  (apply (obj mens) args))
;Memórias iniciais, linha inicial e "segredo inicial"
(define l 0)
(define segredo ())
(define memoria-jogador ())
(define memoria-controle ())
;Variáveis utilizadas para o jogador automático ser um pouco inteligente
(define as-i 0)
(define rs-i 0)
(define as (make-vector 12))
(define rs (make-vector 12))
(define resposta-anterior ())
;Jogador
;Automático
(define (cria-jogador90 papel)
  ;Converte o número n de 0 a 5 por um pino-chave.
  ;As correspondências são as seguintes: 0=red
  ;                                      1=aqua
  ;                                      2=brown 
  ;                                      3=orange
  ;                                      4=yellow
  ;                                      5=lime
  (define (converte n)
    (cond ((= n 0) (set! n 'red)
                   n)
          ((= n 1) (set! n 'aqua)
                   n)
          ((= n 2) (set! n 'brown)
                   n)
          ((= n 3) (set! n 'orange)
                   n)
          ((= n 4) (set! n 'yellow)
                   n)
          ((= n 5) (set! n 'lime)
                   n)))
  ;Percorre elementos da lista lst e dovolve #t caso encontre el e #f caso contrário.
  (define (existe-el? lst el)
    (cond ((null? lst) #f)
          ((seq-pinos-chave=? el (car lst)) #t)
          (else (existe-el? (cdr lst) el))))
  ;Calcula a resposta à adivinha seq em relação ao segredo seg.
  ;Utiliza dois procedimentos definidos internamente: um para calcular os pretos e o outro para calcular os vermelhos.
  (define (calcula-resposta seq seg)
    (let ((lista1 ())
          (lista2 ())
          (p 0)
          (v 0))
      ;Conta o número de pinos do tipo pino numa lista lst.
      (define (conta-n-pinos pino lst)
        (define (conta-n-pinos-aux pino lst n)
          (cond ((null? lst) n)
                ((eq? pino (car lst)) (conta-n-pinos-aux pino (cdr lst) (+ n 1)))
                (else (conta-n-pinos-aux pino (cdr lst) n))))
        (conta-n-pinos-aux pino lst 0))
      (define (calcula-pretos seq seg)
        (do ((i 1 (+ i 1)))
          ((> i 4) p)
          (if (not (eq? (elemento-i-seq-pinos-chave seq i)
                        (elemento-i-seq-pinos-chave seg i)))
              (begin
                (set! lista1 (cons (elemento-i-seq-pinos-chave seq i) lista1))
                (set! lista2 (cons (elemento-i-seq-pinos-chave seg i) lista2)))
              (set! p (+ p 1))))
        p)
      (define (calcula-vermelhos lista1 lista2)
        (let ((red1 0)
              (red2 0)
              (yellow1 0)
              (yellow2 0)
              (brown1 0)
              (brown2 0)
              (aqua1 0)
              (aqua2 0)
              (orange1 0)
              (orange2 0)
              (lime1 0)
              (lime2 0))
          (if (null? lista1)
              (set! v v)
              (begin
                (set! red1 (conta-n-pinos 'red lista1))
                (set! red2 (conta-n-pinos 'red lista2))
                (set! yellow1 (conta-n-pinos 'yellow lista1))
                (set! yellow2 (conta-n-pinos 'yellow lista2))
                (set! brown1 (conta-n-pinos 'brown lista1))
                (set! brown2 (conta-n-pinos 'brown lista2))
                (set! aqua1 (conta-n-pinos 'aqua lista1))
                (set! aqua2 (conta-n-pinos 'aqua lista2))
                (set! orange1 (conta-n-pinos 'orange lista1))
                (set! orange2 (conta-n-pinos 'orange lista2))
                (set! lime1 (conta-n-pinos 'lime lista1))
                (set! lime2 (conta-n-pinos 'lime lista2))
                (cond ((= 0 red1) (set! v v))
                      ((= 0 red2) (set! v v))
                      ((= red1 red2) (set! v (+ v red1)))
                      (else (set! v (+ v (abs (- red1 red2))))))
                (cond ((= 0 yellow1) (set! v v))
                      ((= 0 yellow2) (set! v v))
                      ((= yellow1 yellow2) (set! v (+ v yellow1)))  
                      (else (set! v (+ v (abs (- yellow1 yellow2))))))
                (cond ((= 0 brown1) (set! v v))
                      ((= 0 brown2) (set! v v))
                      ((= brown1 brown2) (set! v (+ v brown1)))  
                      (else (set! v (+ v (abs (- brown1 brown2))))))
                (cond ((= 0 aqua1) (set! v v))
                      ((= 0 aqua2) (set! v v))
                      ((= aqua1 aqua2) (set! v (+ v aqua1)))  
                      (else (set! v (+ v (abs (- aqua1 aqua2))))))
                (cond ((= 0 orange1) (set! v v))
                      ((= 0 orange2) (set! v v))
                      ((= orange1 orange2) (set! v (+ v orange1)))  
                      (else (set! v (+ v (abs (- orange1 orange2))))))
                (cond ((= 0 lime1) (set! v v))
                      ((= 0 lime2) (set! v v))
                      ((= lime1 lime2) (set! v (+ v lime1)))  
                      (else (set! v (+ v (abs (- lime1 lime2))))))))
          v))
      (faz-resposta (calcula-pretos seq seg) (calcula-vermelhos lista1 lista2))))
  ;Recebe o vector v e devolve o elemento desse vector que corresponde à melhor resposta nesse vector.
  ;Utiliza um procedimento definido internamente para converter um número de 1 a 13 numa resposta (foi feito assim para quantificar/dar valor a cada uma das respostas possíveis). A ordem decrescente por valor das respostas é a seguinte (sendo o elemento da esquerda o número de pretos e o da direita o número de vermelhos:         (2 2) (1 3) (0 4) (3 0) (2 1) (1 2) (0 3) (2 0) (1 1) (0 2) (1 0) (0 1) (0 0).
  (define (melhor-r v)
    (let ((melhor-resposta 0))
      (define (converte-n-resposta n)
        (cond ((= 13 n) (faz-resposta 2 2))
              ((= 12 n) (faz-resposta 1 3))
              ((= 11 n) (faz-resposta 0 4))
              ((= 10 n) (faz-resposta 3 0))
              ((= 9 n) (faz-resposta 2 1))
              ((= 8 n) (faz-resposta 1 2))
              ((= 7 n) (faz-resposta 0 3))
              ((= 6 n) (faz-resposta 2 0))
              ((= 5 n) (faz-resposta 1 1))
              ((= 4 n) (faz-resposta 0 2))
              ((= 3 n) (faz-resposta 1 0))
              ((= 2 n) (faz-resposta 0 1))
              ((= 1 n) (faz-resposta 0 0))))
      (dolist (el (vector->list v))
              (cond ((equal? el (cons 2 2))
                     (set! melhor-resposta 13))
                    ((equal? el (cons 1 3))
                     (if (< melhor-resposta 13)
                         (set! melhor-resposta 12)))
                    ((equal? el (cons 0 4))
                     (if (< melhor-resposta 12)
                         (set! melhor-resposta 11)))
                    ((equal? el (cons 3 0))
                     (if (< melhor-resposta 11)
                         (set! melhor-resposta 10)))
                    ((equal? el (cons 2 1))
                     (if (< melhor-resposta 10)
                         (set! melhor-resposta 9)))
                    ((equal? el (cons 1 2))
                     (if (< melhor-resposta 9)
                         (set! melhor-resposta 8)))
                    ((equal? el (cons 0 3))
                     (if (< melhor-resposta 8)
                         (set! melhor-resposta 7)))
                    ((equal? el (cons 2 0))
                     (if (< melhor-resposta 7)
                         (set! melhor-resposta 6)))
                    ((equal? el (cons 1 1))
                     (if (< melhor-resposta 6)
                         (set! melhor-resposta 5)))
                    ((equal? el (cons 0 2))
                     (if (< melhor-resposta 5)
                         (set! melhor-resposta 4)))
                    ((equal? el (cons 1 0))
                     (if (< melhor-resposta 4)
                         (set! melhor-resposta 3)))
                    ((equal? el (cons 0 1))
                     (if (< melhor-resposta 3)
                         (set! melhor-resposta 2)))
                    ((equal? el (cons 0 0))
                     (if (< melhor-resposta 2)
                         (set! melhor-resposta 1)))))
      (converte-n-resposta melhor-resposta)))
  ;Recebe um vector e indica a posição nesse vector da melhor resposta nele contida (caso haja mais que uma devolve a posição da primeira delas).
  (define (ref-melhor-resposta v)
    (define (ref-melhor-resposta-aux v vector n)
      (if (null? v)
          n
          (if (equal? (car v) (melhor-r vector))
              n
              (ref-melhor-resposta-aux (cdr v) vector (+ n 1)))))
    (ref-melhor-resposta-aux (vector->list v) v 0))
  (define (novo-segredo)
    (begin
      (set! segredo (cria-seq-pinos-chave (converte (random 6))
                                          (converte (random 6))
                                          (converte (random 6))
                                          (converte (random 6))))
      segredo))
  (define (responde-adivinha s)
    (let ((r ()))
      (set! r (calcula-resposta s segredo))
      r))
  (define (adivinha)
    (let ((a ()))
      (begin 
        (set! a (cria-seq-pinos-chave (converte (random 6))
                                      (converte (random 6))
                                      (converte (random 6))
                                      (converte (random 6))))
        (if (existe-el? memoria-jogador a)
            (adivinha)
            (cond ((null? resposta-anterior) (set! memoria-jogador (cons a memoria-jogador))
                                             (vector-set! as as-i a)
                                             (set! as-i (+ as-i 1))
                                             a)
                  ((equal? (calcula-resposta a (vector-ref as (ref-melhor-resposta rs)))
                           (melhor-r rs)) (set! memoria-jogador (cons a memoria-jogador))
                                          (vector-set! as as-i a)
                                          (set! as-i (+ as-i 1))
                                          a)
                  (else (adivinha)))))))
  (define (recebe-resposta r)
    (vector-set! rs rs-i r)
    (set! rs-i (+ rs-i 1))
    (set! resposta-anterior r))
  (cond ((eq? papel 'adivinha) (lambda (arg)
                                 (case arg
                                   ((adivinha) adivinha)
                                   ((recebe-resposta) recebe-resposta)
                                   (else (error "jogador:pedido desconhecido")))))
        ((eq? papel 'segredo) (lambda (arg)
                                (case arg
                                  ((novo-segredo) novo-segredo)
                                  ((responde-adivinha) responde-adivinha)
                                  (else (error "jogador:pedido desconhecido")))))
        (else (error "jogador:papel inválido"))))

;Programa
;de
;Controle
(define (cria-controle nome papel)
  (let ((r ())
        (a ()))
    ;Vê se a sequência de pinos chave s tem pinos do tipo white.
    (define (tem-brancos? s)
      (let ((r #f))
        (dolist (el s)
                (if (eq? el 'white)
                    (set! r #t)
                    (set! r r)))
        r))
    ;Percorre elementos da lista lst e dovolve #t caso encontre el e #f caso contrário.
    (define (existe-el? lst el)
      (cond ((null? lst) #f)
            ((seq-pinos-chave=? el (car lst)) #t)
            (else (existe-el? (cdr lst) el))))
    ;Calcula a resposta à adivinha seq em relação ao segredo seg.
    ;Utiliza dois procedimentos definidos internamente: um para calcular os pretos e o outro para calcular os vermelhos.
    (define (calcula-resposta seq seg)
      (let ((lista1 ())
            (lista2 ())
            (p 0)
            (v 0))
        ;Conta o número de pinos do tipo pino numa lista lst.
        (define (conta-n-pinos pino lst)
          (define (conta-n-pinos-aux pino lst n)
            (cond ((null? lst) n)
                  ((eq? pino (car lst)) (conta-n-pinos-aux pino (cdr lst) (+ n 1)))
                  (else (conta-n-pinos-aux pino (cdr lst) n))))
          (conta-n-pinos-aux pino lst 0))
        (define (calcula-pretos seq seg)
          (do ((i 1 (+ i 1)))
            ((> i 4) p)
            (if (not (eq? (elemento-i-seq-pinos-chave seq i)
                          (elemento-i-seq-pinos-chave seg i)))
                (begin
                  (set! lista1 (cons (elemento-i-seq-pinos-chave seq i) lista1))
                  (set! lista2 (cons (elemento-i-seq-pinos-chave seg i) lista2)))
                (set! p (+ p 1))))
          p)
        (define (calcula-vermelhos lista1 lista2)
          (let ((red1 0)
                (red2 0)
                (yellow1 0)
                (yellow2 0)
                (brown1 0)
                (brown2 0)
                (aqua1 0)
                (aqua2 0)
                (orange1 0)
                (orange2 0)
                (lime1 0)
                (lime2 0))
            (if (null? lista1)
                (set! v v)
                (begin
                  (set! red1 (conta-n-pinos 'red lista1))
                  (set! red2 (conta-n-pinos 'red lista2))
                  (set! yellow1 (conta-n-pinos 'yellow lista1))
                  (set! yellow2 (conta-n-pinos 'yellow lista2))
                  (set! brown1 (conta-n-pinos 'brown lista1))
                  (set! brown2 (conta-n-pinos 'brown lista2))
                  (set! aqua1 (conta-n-pinos 'aqua lista1))
                  (set! aqua2 (conta-n-pinos 'aqua lista2))
                  (set! orange1 (conta-n-pinos 'orange lista1))
                  (set! orange2 (conta-n-pinos 'orange lista2))
                  (set! lime1 (conta-n-pinos 'lime lista1))
                  (set! lime2 (conta-n-pinos 'lime lista2))
                  (cond ((= 0 red1) (set! v v))
                        ((= 0 red2) (set! v v))
                        ((= red1 red2) (set! v (+ v red1)))
                        (else (set! v (+ v (abs (- red1 red2))))))
                  (cond ((= 0 yellow1) (set! v v))
                        ((= 0 yellow2) (set! v v))
                        ((= yellow1 yellow2) (set! v (+ v yellow1)))  
                        (else (set! v (+ v (abs (- yellow1 yellow2))))))
                  (cond ((= 0 brown1) (set! v v))
                        ((= 0 brown2) (set! v v))
                        ((= brown1 brown2) (set! v (+ v brown1)))  
                        (else (set! v (+ v (abs (- brown1 brown2))))))
                  (cond ((= 0 aqua1) (set! v v))
                        ((= 0 aqua2) (set! v v))
                        ((= aqua1 aqua2) (set! v (+ v aqua1)))  
                        (else (set! v (+ v (abs (- aqua1 aqua2))))))
                  (cond ((= 0 orange1) (set! v v))
                        ((= 0 orange2) (set! v v))
                        ((= orange1 orange2) (set! v (+ v orange1)))  
                        (else (set! v (+ v (abs (- orange1 orange2))))))
                  (cond ((= 0 lime1) (set! v v))
                        ((= 0 lime2) (set! v v))
                        ((= lime1 lime2) (set! v (+ v lime1)))  
                        (else (set! v (+ v (abs (- lime1 lime2))))))))
            v))
        (faz-resposta (calcula-pretos seq seg) (calcula-vermelhos lista1 lista2))))
    (define (nova-adivinha s)
      (set! r (em (cria-jogador90 'segredo) 'responde-adivinha s))
      (if (seq-pinos-chave=? s segredo) 
          (begin
            (em mm-interface 'fpmm-mostra-adivinha s l)
            (em mm-interface 'fpmm-mostra-resposta r l)
            (em mm-interface 'fpmm-mostra-segredo segredo)
            (em mm-interface 'fpmm-fim-jogo (string-append (symbol->string nome) " Ganhou")))
          (begin
            (em mm-interface 'fpmm-mostra-adivinha s l)
            (cond ((tem-brancos? s) (em mm-interface 'fpmm-fim-jogo (string-append (symbol->string nome) " Perdeu")))
                  ((existe-el? memoria-controle s) (em mm-interface 'fpmm-mostra-segredo segredo)
                                                   (em mm-interface 'fpmm-fim-jogo (string-append (symbol->string nome) " Perdeu")))
                  ((= l 11) (em mm-interface 'fpmm-mostra-segredo segredo)
                            (em mm-interface 'fpmm-mostra-resposta r l)
                            (em mm-interface 'fpmm-fim-jogo "Computador Ganhou"))
                  (else (set! memoria-controle (cons s memoria-controle))
                        (em mm-interface 'fpmm-mostra-resposta r l)
                        (set! l (+ l 1))))
            (em mm-interface 'fpmm-pede-adivinha l))))
    (define (novo-segredo s)
      (if (not (tem-brancos? s))
          (begin
            (set! segredo s)
            (em mm-interface 'fpmm-mostra-segredo segredo)
            (set! a (em (cria-jogador90 'adivinha) 'adivinha))
            (em mm-interface 'fpmm-mostra-adivinha a l)
            (set! r (calcula-resposta a segredo))
            (em (cria-jogador90 'adivinha) 'recebe-resposta r)
            (em mm-interface 'fpmm-mostra-resposta r l)
            (set! l (+ l 1))
            (set! memoria-controle (cons a memoria-controle))
            (if (= (resposta-pretos r) 4)
                (em mm-interface 'fpmm-fim-jogo "Computador Ganhou")
                (em mm-interface 'fpmm-pede-continuar)))
          (em mm-interface 'fpmm-fim-jogo (string-append (symbol->string nome) " Perdeu"))))
    (define (continuar)
      (set! a (em (cria-jogador90 'adivinha) 'adivinha))
      (em mm-interface 'fpmm-mostra-adivinha a l)
      (set! r (calcula-resposta a segredo))
      (if (existe-el? memoria-controle a)
          (begin
            (em mm-interface 'fpmm-mostra-resposta r l)
            (em mm-interface 'fpmm-fim-jogo " Computador Perdeu"))
          (begin
            (em (cria-jogador90 'adivinha) 'recebe-resposta r)
            (em mm-interface 'fpmm-mostra-resposta r l)
            (set! l (+ l 1))
            (set! memoria-controle (cons a memoria-controle))
            (cond ((= (resposta-pretos r) 4) (em mm-interface 'fpmm-fim-jogo "Computador Ganhou"))
                  ((= 12 l) (em mm-interface 'fpmm-fim-jogo (string-append (symbol->string nome) " Ganhou")))
                  (else (em mm-interface 'fpmm-pede-continuar))))))
    (em mm-interface 'fpmm-inicia-jogo)
    (cond ((eq? 'segredo papel) (em mm-interface 'fpmm-escreve-linha (string-append "Olá" " " (symbol->string nome) "!") 1)
                                (em mm-interface 'fpmm-escreve-linha "O seu objectivo é adivinhar o segredo gerado automaticamente." 3)
                                (em mm-interface 'fpmm-escreve-linha "Para isso deve introduzir uma adivinha na primeira linha vaga." 5)
                                (em mm-interface 'fpmm-escreve-linha "Basta carregar em cada uma das posições da grelha e estas ficam coloridas com a cor" 6)
                                (em mm-interface 'fpmm-escreve-linha "seleccionada no bloco de cores em baixo. Para mudar de cor basta carregar na cor" 7) 
                                (em mm-interface 'fpmm-escreve-linha "pretendida no bloco de cores. Quando tiver terminado carregue em Jogar." 8)
                                (set! segredo (em (cria-jogador90 'segredo) 'novo-segredo))
                                (em mm-interface 'fpmm-pede-adivinha l))
          ((eq? 'adivinha papel) (em mm-interface 'fpmm-escreve-linha (string-append "Olá" " " (symbol->string nome) "!") 1)
                                 (em mm-interface 'fpmm-escreve-linha "O seu objectivo é criar um novo segredo para o jogador automático tentar adivinhar." 3)
                                 (em mm-interface 'fpmm-escreve-linha "Para isso deve introduzir um segredo na linha preta." 5)
                                 (em mm-interface 'fpmm-escreve-linha "Basta carregar em cada uma das posições da grelha e estas ficam coloridas com a cor" 6)
                                 (em mm-interface 'fpmm-escreve-linha "seleccionada no bloco de cores em baixo. Para mudar de cor basta carregar na cor" 7)
                                 (em mm-interface 'fpmm-escreve-linha "pretendida no bloco de cores. Quando tiver terminado carregue em Jogar." 8)
                                 (em mm-interface 'fpmm-pede-segredo))
          (else (error "controle:papel desconhecido")))
    (lambda (arg)
      (case arg
        ((nova-adivinha) nova-adivinha)
        ((novo-segredo) novo-segredo)
        ((continuar) continuar)))))

